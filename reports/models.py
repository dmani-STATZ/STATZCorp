from django.db import models
from django.contrib.auth import get_user_model
from django.core.serializers.json import DjangoJSONEncoder

User = get_user_model()

class QueryLog(models.Model):
    """Model to log all queries made through the NLI system."""
    
    raw_query = models.TextField(
        help_text="The original query text as entered by the user"
    )
    normalized_query = models.TextField(
        help_text="The normalized/preprocessed query text"
    )
    parsed_fields = models.JSONField(
        default=dict,
        encoder=DjangoJSONEncoder,
        help_text="Dictionary mapping natural language terms to database fields"
    )
    query_type = models.CharField(
        max_length=50,
        help_text="Type of query (e.g., SELECT, COUNT, etc.)"
    )
    execution_time = models.FloatField(
        help_text="Time taken to execute the query in seconds"
    )
    was_successful = models.BooleanField(
        default=False,
        help_text="Whether the query was executed successfully"
    )
    error_message = models.TextField(
        null=True,
        blank=True,
        help_text="Error message if query failed"
    )
    result_count = models.IntegerField(
        default=0,
        help_text="Number of results returned by the query"
    )
    user = models.ForeignKey(
        User,
        on_delete=models.SET_NULL,
        null=True,
        help_text="User who made the query"
    )
    timestamp = models.DateTimeField(
        auto_now_add=True,
        help_text="When the query was made"
    )
    user_feedback = models.TextField(
        null=True,
        blank=True,
        help_text="Feedback provided by the user about the query results"
    )
    corrected_query = models.TextField(
        null=True,
        blank=True,
        help_text="Corrected version of the query provided through training"
    )
    field_mappings = models.JSONField(
        default=dict,
        encoder=DjangoJSONEncoder,
        help_text="Manual field mappings provided through training"
    )
    notes = models.TextField(
        null=True,
        blank=True,
        help_text="Training notes about this query"
    )
    corrections_processed = models.BooleanField(
        default=False,
        help_text="Whether corrections have been processed by the learning engine"
    )
    generated_sql = models.TextField(
        null=True, 
        blank=True,
        help_text="SQL query generated by the NLI system"
    )
    verified_sql = models.TextField(
        null=True, 
        blank=True,
        help_text="Correct SQL query verified in SSMS"
    )
    sql_verified = models.BooleanField(
        default=False,
        help_text="Whether this query has been verified in SSMS"
    )
    sql_verification_date = models.DateTimeField(
        null=True, 
        blank=True,
        help_text="When this query was verified"
    )
    sql_verified_by = models.ForeignKey(
        User,
        on_delete=models.SET_NULL,
        null=True,
        related_name='sql_verifications',
        help_text="User who verified the SQL"
    )
    orm_translation = models.TextField(
        null=True, 
        blank=True,
        help_text="Django ORM translation of the verified SQL"
    )
    similar_queries = models.ManyToManyField(
        'self',
        symmetrical=False,
        help_text="Queries that are similar to this one"
    )

    class Meta:
        ordering = ['-timestamp']
        indexes = [
            models.Index(fields=['timestamp']),
            models.Index(fields=['was_successful']),
            models.Index(fields=['query_type']),
        ]

    def __str__(self):
        return f"{self.raw_query[:50]}..."

class QueryPattern(models.Model):
    """Model to store successful query patterns."""
    
    original_pattern = models.TextField(
        help_text="The original query pattern"
    )
    corrected_pattern = models.TextField(
        help_text="The corrected/normalized query pattern"
    )
    usage_count = models.IntegerField(
        default=0,
        help_text="Number of times this pattern has been used"
    )
    success_count = models.IntegerField(
        default=0,
        help_text="Number of successful queries using this pattern"
    )
    success_rate = models.FloatField(
        default=0.0,
        help_text="Success rate of this pattern (percentage)"
    )
    created_at = models.DateTimeField(
        auto_now_add=True,
        help_text="When this pattern was first created"
    )
    updated_at = models.DateTimeField(
        auto_now=True,
        help_text="When this pattern was last updated"
    )

    class Meta:
        ordering = ['-usage_count']
        indexes = [
            models.Index(fields=['usage_count']),
            models.Index(fields=['success_count']),
            models.Index(fields=['success_rate']),
        ]

    def __str__(self):
        return f"{self.original_pattern[:50]}..."

    def update_success_rate(self):
        """Update the success rate based on usage and success counts."""
        if self.usage_count == 0:
            self.success_rate = 0
        else:
            self.success_rate = (self.success_count / self.usage_count) * 100
        self.save()

class FieldMapping(models.Model):
    """Model to store mappings between natural language terms and database fields."""
    
    natural_term = models.CharField(
        max_length=100,
        unique=True,
        help_text="The natural language term"
    )
    db_field = models.CharField(
        max_length=100,
        help_text="The corresponding database field"
    )
    confidence = models.FloatField(
        default=0.5,
        help_text="Confidence score for this mapping"
    )
    usage_count = models.IntegerField(
        default=0,
        help_text="Number of times this mapping has been used"
    )
    created_at = models.DateTimeField(
        auto_now_add=True,
        help_text="When this mapping was first created"
    )
    updated_at = models.DateTimeField(
        auto_now=True,
        help_text="When this mapping was last updated"
    )

    class Meta:
        ordering = ['-confidence', '-usage_count']
        indexes = [
            models.Index(fields=['natural_term']),
            models.Index(fields=['db_field']),
            models.Index(fields=['confidence']),
        ]

    def __str__(self):
        return f"{self.natural_term} -> {self.db_field}"
